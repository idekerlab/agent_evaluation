'''
A JudgementSpace enables the comparison and analysis of a group of human reviewers and Reviewer agents.

The analysis is based on an ordered list of ReviewSet objects, each containing Reviews generated by the reviewer group.

Each ReviewSet must contain the same reviewers.

The comparison between the reviewers is based on their decision history, processed to create judgement vectors (jvecs)

The JudgmentSpace object can generate and store the jvecs for each reviewer. 

It can also produce statistical analyses and visualizations of the jvecs and other information about the reviewers and the review sets.

'''

from models.review import Review
from models.review_set import ReviewSet  
import services.review_judgments as review_judgments
import numpy as np
import io
import base64
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.cluster import hierarchy
from scipy.spatial.distance import pdist, squareform
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE

import umap
from collections import defaultdict
from models.agent import Agent


class JudgmentSpace:
    def __init__(self, db, review_sets, name="unnamed", description=None, object_id=None, created=None):
        self.db = db
        self.review_sets = review_sets
        self.name = name
        self.description = description
        self.object_id = object_id
        self.created = created
        self.reviewer_judgment_dict = None

    @classmethod
    def create(cls, db, review_sets, name=None, description=None):
        properties = {
            "review_sets": [review_set.object_id for review_set in review_sets],
            "name": name,
            "description": description,
        }
        object_id, created, _ = db.add(object_id=None, properties=properties, object_type="judgment_space")
        return cls(db=db, review_sets=review_sets, name=name, description=description, object_id=object_id, created=created)

    @classmethod
    def load(cls, db, object_id):
        properties, _ = db.load(object_id)
        if properties:
            review_sets = [ReviewSet.load(db, review_set_id) for review_set_id in properties['review_sets']]
            return cls(db, review_sets=review_sets, **properties)
        return None

    def update(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
        self.db.update(self.object_id, kwargs)

    def delete(self):
        self.db.remove(self.object_id)

    def generate_reviewer_judgment_dict(self):
        self.reviewer_judgment_dict = review_judgments.create_reviewer_judgment_dict_for_review_set_list(self.db, self.review_sets)

    def get_reviewer_jvec(self, reviewer_id):
        if self.reviewer_judgment_dict is None:
            self.generate_reviewer_judgment_dict()
        return self.reviewer_judgment_dict.get(reviewer_id)

    def get_all_reviewer_jvecs(self):
        if self.reviewer_judgment_dict is None:
            self.generate_reviewer_judgment_dict()
        return self.reviewer_judgment_dict

    def generate_visualizations(self):
        self.generate_reviewer_judgment_dict()
        reduced_dim_plot = self._generate_reduced_dim_plot()
        heatmap = self._generate_heatmap()
        return {
            "reduced_dim_plot": reduced_dim_plot,
            "heatmap": heatmap
        }

    def _generate_reduced_dim_plot(self, plot_type='PCA', n_components=2, random_state=42, figsize=(10, 8)):
        reviewer_data = {reviewer_id: {'judgment_vector': jvec} for reviewer_id, jvec in self.reviewer_judgment_dict.items()}
        
        judgment_vectors = []
        labels = []
        for reviewer_id, data in reviewer_data.items():
            reviewer = Agent.load(self.db, reviewer_id)
            judgment_vectors.append(data['judgment_vector'])
            labels.append(reviewer.name)

        all_reviewers = np.vstack(judgment_vectors)
        n_samples, n_features = all_reviewers.shape
        n_components = min(n_components, n_samples, n_features)

        if plot_type == 'PCA':
            reducer = PCA(n_components=n_components, random_state=random_state)
        elif plot_type == 'UMAP':
            reducer = umap.UMAP(n_components=n_components, random_state=random_state)
        elif plot_type == 'TSNE':
            reducer = TSNE(n_components=n_components, random_state=random_state)
        else:
            raise ValueError("Invalid plot_type. Choose 'PCA', 'UMAP', or 'TSNE'.")

        reduced_data = reducer.fit_transform(all_reviewers)

        plt.figure(figsize=figsize)
        colors = plt.cm.rainbow(np.linspace(0, 1, len(set(labels))))
        color_dict = {label: color for label, color in zip(set(labels), colors)}
        markers = ['o', 's', '^', 'D', 'v', '<', '>', 'p', '*', 'h', 'H', '+', 'x', 'd', '|', '_']
        marker_dict = {label: marker for label, marker in zip(set(labels), markers)}

        self._plot_scatter_with_overlap_handling(reduced_data, labels, color_dict, marker_dict)

        plt.title(f"Reviewers in {plot_type} Space")
        plt.xlabel(f"{plot_type}1")
        plt.ylabel(f"{plot_type}2")
        plt.legend()
        plt.grid(True, alpha=0.3)

        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='svg')
        img_buffer.seek(0)
        return img_buffer.getvalue().decode()

    def _plot_scatter_with_overlap_handling(self, reduced_data, labels, color_dict, marker_dict):
        point_groups = defaultdict(list)
        for i, (x, y) in enumerate(reduced_data):
            point_groups[(x, y)].append(i)
        
        for (x, y), indices in point_groups.items():
            if len(indices) == 1:
                i = indices[0]
                label = labels[i]
                plt.scatter(x, y, 
                            c=[color_dict[label]], 
                            marker=marker_dict[label], 
                            label=label if label not in plt.gca().get_legend_handles_labels()[1] else "",
                            alpha=0.7)
            else:
                unique_labels = set(labels[i] for i in indices)
                for j, label in enumerate(unique_labels):
                    offset = j * 0.1
                    plt.scatter(x + offset, y + offset, 
                                c=[color_dict[label]], 
                                marker=marker_dict[label], 
                                label=label if label not in plt.gca().get_legend_handles_labels()[1] else "",
                                alpha=0.7)

    def _generate_heatmap(self, figsize=(12, 10)):
        data = np.array(list(self.reviewer_judgment_dict.values()))
        
        # Perform hierarchical clustering
        linkage = hierarchy.linkage(data, method='ward')
        
        # Compute distance matrix
        dist_matrix = pdist(data)
        dist_matrix = squareform(dist_matrix)
        
        # Create labels
        labels = [Agent.load(self.db, reviewer_id).name for reviewer_id in self.reviewer_judgment_dict.keys()]
        
        plt.figure(figsize=figsize)
        sns.clustermap(dist_matrix, 
                       row_linkage=linkage, 
                       col_linkage=linkage,
                       xticklabels=labels,
                       yticklabels=labels,
                       cmap='YlGnBu',
                       cbar_kws={'label': 'Distance'})
        plt.title('Reviewer Similarity Heatmap')
        
        img_buffer = io.BytesIO()
        plt.savefig(img_buffer, format='svg')
        img_buffer.seek(0)
        return img_buffer.getvalue().decode()