#!/usr/bin/env python3

"""
Network utility functions for working with NetworkX and CX2 networks.
Uses standard ndex2 client library for CX2 conversions.
"""

import networkx as nx
import json
import os
from typing import Dict, List, Any, Set, Optional, Tuple, Union
from datetime import datetime
from ndex2.cx2 import CX2Network
from ndex2.cx2 import CX2NetworkXFactory, NetworkXToCX2NetworkFactory, RawCX2NetworkFactory

def cx2_to_networkx(cx2_network: CX2Network) -> nx.Graph:
    """
    Convert CX2 network to NetworkX graph using standard ndex2 library
    
    Args:
        cx2_network: CX2 network object
        
    Returns:
        NetworkX graph
    """
    # Use the standard CX2NetworkXFactory to convert CX2 to NetworkX
    converter = CX2NetworkXFactory()
    G = converter.get_graph(cx2_network)
    
    # Create a lookup from gene symbols to node IDs for compatibility with older code
    gene_to_id = {}
    
    # Add mappings from names/gene symbols to node IDs
    for node_id, attrs in G.nodes(data=True):
        # Get node name
        node_name = attrs.get('name', '')
        
        # Store gene symbol to node ID mapping if available
        if node_name:
            gene_to_id[node_name] = node_id
            
        # Also use GeneSymbol as a lookup if different from name
        gene_symbol = attrs.get('GeneSymbol', '')
        if gene_symbol and gene_symbol != node_name:
            gene_to_id[gene_symbol] = node_id
    
    # Store the gene symbol to ID mapping in graph metadata for compatibility
    G.graph['gene_to_id'] = gene_to_id
    
    return G

def networkx_to_cx2(G: nx.Graph) -> Dict:
    """
    Convert a NetworkX graph to a CX2 network in JSON format using standard ndex2 library.
    
    Args:
        G: NetworkX graph
        
    Returns:
        Dictionary in CX2 format
    """
    # Use the standard NetworkXToCX2NetworkFactory to convert NetworkX to CX2Network
    factory = NetworkXToCX2NetworkFactory()
    cx2_network = factory.get_cx2network(G)
    
    # Ensure we have a name
    if not cx2_network.get_name():
        cx2_network.set_name("Generated Network")
    
    # Add description if missing
    network_attrs = cx2_network.get_network_attributes()
    if 'description' not in network_attrs:
        cx2_network.set_network_attribute('description', "Network generated by algorithm")
    
    # Add version if missing
    if 'version' not in network_attrs:
        cx2_network.set_network_attribute('version', "1.0")
    
    # Make sure propagation_weight attribute is properly declared
    # This is important for preserving weights from the propagation algorithms
    attr_declarations = cx2_network.get_attribute_declarations()
    if 'nodes' in attr_declarations and 'propagation_weight' not in attr_declarations['nodes']:
        attr_declarations['nodes']['propagation_weight'] = {'d': 'double'}
        cx2_network.set_attribute_declarations(attr_declarations)
    
    # Get the full CX2 JSON representation
    cx2_data = cx2_network.to_cx2()
    
    # Ensure visualProperties are present if they're not included by the factory
    # This is important for preserving visual styles
    has_visual_props = False
    for item in cx2_data:
        if "visualProperties" in item:
            has_visual_props = True
            break
            
    if not has_visual_props:
        # Add default visualProperties section
        cx2_data.append({"visualEditorProperties": [{"properties": {
            "nodeSizeLocked": False,
            "arrowColorMatchesEdge": True,
            "nodeCustomGraphicsSizeSync": True
        }}]})
        
        cx2_data.append({"visualProperties": [{"default": {}}]})
    
    return cx2_data

def cx2_network_to_cx2_json(cx2_network: CX2Network) -> Dict:
    """
    Convert a CX2Network object to CX2 JSON format compatible with NDEx.
    
    Args:
        cx2_network: CX2Network object
        
    Returns:
        Dictionary in CX2 format
    """
    # Use the CX2Network's built-in to_cx2() method to get proper CX2 JSON
    return cx2_network.to_cx2()

def extract_subnetwork(G: nx.Graph, node_ids: List[str], include_connecting_edges: bool = True) -> nx.Graph:
    """
    Extract a subnetwork containing only specified nodes and optionally their connecting edges.
    
    Args:
        G: Full NetworkX graph
        node_ids: List of node IDs to include in the subnetwork
        include_connecting_edges: If True, include edges between selected nodes
        
    Returns:
        NetworkX subgraph with only the specified nodes and edges
    """
    # Convert node_ids to a set for faster lookup
    node_set = set(node_ids)
    
    # Filter to ensure all nodes exist in the graph
    existing_nodes = [n for n in node_ids if n in G]
    
    if include_connecting_edges:
        # Create a subgraph with the specified nodes and all edges between them
        subgraph = G.subgraph(existing_nodes).copy()
    else:
        # Create an empty graph with the same properties as G
        subgraph = nx.Graph()
        subgraph.graph = G.graph.copy()
        
        # Add only the specified nodes with their attributes
        for node_id in existing_nodes:
            subgraph.add_node(node_id, **G.nodes[node_id])
    
    return subgraph

def save_cx2_to_file(cx2_data: Union[Dict, CX2Network], output_path: str) -> None:
    """
    Save CX2 network data to a JSON file.
    
    Args:
        cx2_data: CX2 network data (either as a dict or CX2Network object)
        output_path: Path to save the file
        
    Returns:
        None
    """
    # Create output directory if it doesn't exist
    os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
    
    # Convert to dict if we received a CX2Network object
    if isinstance(cx2_data, CX2Network):
        cx2_data = cx2_data.to_cx2()
    
    with open(output_path, 'w') as f:
        json.dump(cx2_data, f, indent=2)
    print(f"Saved CX2 network to {output_path}")

def get_experimental_data_properties(G: nx.Graph) -> Dict[str, List[str]]:
    """
    Identify potential experimental data properties in the graph
    
    Args:
        G: NetworkX graph
        
    Returns:
        Dictionary of property groups and their property names
    """
    # Count occurrences of each property
    property_counts = {}
    numeric_properties = set()
    
    for node, attrs in G.nodes(data=True):
        for key, value in attrs.items():
            if key not in property_counts:
                property_counts[key] = 0
            property_counts[key] += 1
            
            # Check if property is numeric
            if isinstance(value, (int, float)) and not isinstance(value, bool):
                numeric_properties.add(key)
    
    # Categorize properties
    common_properties = set()
    experimental_properties = set()
    
    # Define known metadata properties that are not experimental data
    metadata_properties = {
        'id', 'name', 'GeneSymbol', 'x', 'y', 'type', 'represents', 
        'viral_protein', 'propagation_weight', 'node_type'
    }
    
    # Threshold for common properties (present in >70% of nodes)
    threshold = 0.7 * G.number_of_nodes()
    
    for prop, count in property_counts.items():
        if prop in metadata_properties:
            continue
            
        if count > threshold:
            common_properties.add(prop)
            
        if prop in numeric_properties and prop not in metadata_properties:
            experimental_properties.add(prop)
    
    # Group properties
    property_groups = {
        'common': list(common_properties),
        'experimental': list(experimental_properties),
        'propagation': ['propagation_weight'] if 'propagation_weight' in property_counts else []
    }
    
    return property_groups

def create_cx2_from_dict(cx2_dict: Dict) -> CX2Network:
    """
    Create a CX2Network object from a CX2 dictionary.
    
    Args:
        cx2_dict: Dictionary in CX2 format
        
    Returns:
        CX2Network object
    """
    # Use the RawCX2NetworkFactory to convert the dict to a CX2Network
    factory = RawCX2NetworkFactory()
    return factory.get_cx2network(cx2_dict)

def merge_visual_properties(target_cx2: Dict, source_cx2: Dict) -> Dict:
    """
    Merge visual properties from source CX2 network into target CX2 network.
    This is useful when creating a new network that should maintain the visual style of the original.
    
    Args:
        target_cx2: Target CX2 network data as dict
        source_cx2: Source CX2 network data as dict with visual properties to copy
        
    Returns:
        Updated target CX2 network with visual properties from source
    """
    # Find visual properties in source
    visual_props = None
    visual_editor_props = None
    
    for item in source_cx2:
        if "visualProperties" in item:
            visual_props = item["visualProperties"]
        elif "visualEditorProperties" in item:
            visual_editor_props = item["visualEditorProperties"]
    
    # Update target with source visual properties
    if visual_props:
        # Remove existing visual properties if any
        target_cx2 = [item for item in target_cx2 if "visualProperties" not in item]
        # Add visual properties from source
        target_cx2.append({"visualProperties": visual_props})
    
    if visual_editor_props:
        # Remove existing visual editor properties if any
        target_cx2 = [item for item in target_cx2 if "visualEditorProperties" not in item]
        # Add visual editor properties from source
        target_cx2.append({"visualEditorProperties": visual_editor_props})
    
    return target_cx2
